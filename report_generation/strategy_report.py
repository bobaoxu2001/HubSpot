"""
Automated Strategy Report Generator.

Consumes computed analytics metrics and produces a client-ready strategy
memorandum covering:

    1. Executive Summary
    2. Competitive Positioning
    3. Risk Analysis
    4. Recommended Actions

The report can be generated in two modes:

- **template** — deterministic, Jinja2-based rendering (no LLM needed).
- **llm** — an LLM synthesises the narrative from structured metrics
  (richer language, higher cost).
"""

from __future__ import annotations

import json
import logging
from datetime import date, datetime
from typing import Any, Dict, List, Optional

import openai

from analysis.queries import (
    aisov_leaderboard,
    competitor_displacement_rate,
    mention_rate_by_llm,
    risk_exposure_index,
    sentiment_distribution,
    visibility_by_intent,
)
from config.settings import get_settings
from data_pipeline.database import execute

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Metric collector
# ---------------------------------------------------------------------------

def collect_metrics(brand: str = "HubSpot") -> Dict[str, Any]:
    """Gather all analytics outputs into a single metrics bundle."""
    return {
        "brand": brand,
        "generated_at": datetime.utcnow().isoformat(),
        "mention_rate_by_llm": mention_rate_by_llm(brand),
        "visibility_by_intent": visibility_by_intent(brand),
        "sentiment_distribution": sentiment_distribution(brand),
        "competitor_displacement": competitor_displacement_rate(brand),
        "risk_exposure": risk_exposure_index(brand),
        "aisov_leaderboard": aisov_leaderboard(),
    }


# ---------------------------------------------------------------------------
# Template-based report
# ---------------------------------------------------------------------------

_TEMPLATE = """\
================================================================================
                   AI BRAND VISIBILITY — STRATEGY MEMORANDUM
                         {brand} · {date}
================================================================================

1. EXECUTIVE SUMMARY
--------------------
This report analyses {brand}'s visibility across major Large Language Models
(ChatGPT, Claude, Perplexity) using {total_responses} classified LLM responses
spanning {n_intents} intent categories.

Overall AI Share of Voice (AISOV): {aisov_score}

Key metrics:
  • Mention rate:              {mention_rate}
  • Average rank score:        {avg_rank}
  • Positive sentiment ratio:  {positive_ratio}
  • Recommendation strength:   {rec_strength}

{mention_breakdown}

2. COMPETITIVE POSITIONING
--------------------------
{competitive_section}

3. RISK ANALYSIS
----------------
{risk_section}

4. RECOMMENDED ACTIONS
----------------------
{recommendations}

================================================================================
                              END OF REPORT
          Generated by AI Brand Visibility Intelligence Engine
================================================================================
"""


def _format_mention_breakdown(data: List[Dict]) -> str:
    if not data:
        return "  (No mention data available.)"
    lines = ["  Mention rate by LLM:"]
    for row in data:
        lines.append(
            f"    • {row['llm_name']:12s}  {float(row['mention_rate']) * 100:5.1f}%  "
            f"({row['mentions']}/{row['total_responses']} responses)"
        )
    return "\n".join(lines)


def _format_competitive(data: List[Dict]) -> str:
    if not data:
        return "  No competitor displacement data available."
    lines = ["  Competitor displacement rates (competitor mentioned WITHOUT {brand}):"]
    for row in data:
        lines.append(
            f"    • {row['competitor']:20s}  displacement={float(row['displacement_rate']) * 100:5.1f}%  "
            f"({row['displacement_count']}/{row['total_competitor_mentions']})"
        )
    return "\n".join(lines)


def _format_risk(data: List[Dict]) -> str:
    if not data:
        return "  No risk data available for risk/criticism prompts."
    lines = ["  Risk exposure by LLM (risk/criticism prompts only):"]
    for row in data:
        lines.append(
            f"    • {row['llm_name']:12s}  risk_index={float(row['risk_index']):.3f}  "
            f"negative={float(row['negative_pct']) * 100:.1f}%  "
            f"criticism={float(row['criticism_pct']) * 100:.1f}%"
        )
    return "\n".join(lines)


def _generate_recommendations(metrics: Dict) -> str:
    """Rule-based recommendation engine."""
    recs: List[str] = []

    # Mention rate recommendations
    for row in metrics.get("mention_rate_by_llm", []):
        rate = float(row["mention_rate"])
        if rate < 0.5:
            recs.append(
                f"  ⚠ LOW VISIBILITY on {row['llm_name']} (mention rate {rate * 100:.0f}%). "
                f"Invest in content optimisation targeting {row['llm_name']}'s training data sources."
            )

    # Sentiment recommendations
    for row in metrics.get("sentiment_distribution", []):
        if row["sentiment"] == "negative" and float(row["pct"]) > 0.2:
            recs.append(
                f"  ⚠ HIGH NEGATIVE SENTIMENT on {row['llm_name']} ({float(row['pct']) * 100:.0f}%). "
                f"Investigate root causes — likely driven by pricing or feature-gap narratives."
            )

    # Competitor displacement
    for row in metrics.get("competitor_displacement", []):
        if float(row["displacement_rate"]) > 0.3:
            recs.append(
                f"  ⚠ {row['competitor']} is displacing {metrics['brand']} in "
                f"{float(row['displacement_rate']) * 100:.0f}% of competitor mentions. "
                f"Create head-to-head comparison content to reclaim share."
            )

    # Risk
    for row in metrics.get("risk_exposure", []):
        if float(row["risk_index"]) > 0.5:
            recs.append(
                f"  ⚠ ELEVATED RISK INDEX on {row['llm_name']} ({float(row['risk_index']):.2f}). "
                f"Proactively publish thought-leadership and case studies to counter criticism."
            )

    if not recs:
        recs.append(
            "  ✓ No critical issues detected.  Continue monitoring AISOV trends weekly."
        )

    return "\n\n".join(recs)


def generate_template_report(brand: str = "HubSpot") -> str:
    """Generate the report using the deterministic template."""
    metrics = collect_metrics(brand)

    # Extract AISOV headline
    leaderboard = metrics.get("aisov_leaderboard", [])
    brand_row = next((r for r in leaderboard if r["brand_name"] == brand), None)
    aisov_score = f"{float(brand_row['aisov_score']):.4f}" if brand_row else "N/A"
    mention_rate = f"{float(brand_row['mention_rate']) * 100:.1f}%" if brand_row else "N/A"
    avg_rank = f"{float(brand_row['avg_rank_score']):.4f}" if brand_row else "N/A"
    pos_ratio = f"{float(brand_row['positive_sentiment_ratio']) * 100:.1f}%" if brand_row else "N/A"
    rec_strength = f"{float(brand_row['recommendation_strength_avg']):.4f}" if brand_row else "N/A"
    sample = brand_row["sample_size"] if brand_row else 0

    intents = metrics.get("visibility_by_intent", [])

    report = _TEMPLATE.format(
        brand=brand,
        date=date.today().isoformat(),
        total_responses=sample,
        n_intents=len(intents),
        aisov_score=aisov_score,
        mention_rate=mention_rate,
        avg_rank=avg_rank,
        positive_ratio=pos_ratio,
        rec_strength=rec_strength,
        mention_breakdown=_format_mention_breakdown(metrics["mention_rate_by_llm"]),
        competitive_section=_format_competitive(metrics["competitor_displacement"]),
        risk_section=_format_risk(metrics["risk_exposure"]),
        recommendations=_generate_recommendations(metrics),
    )

    return report


# ---------------------------------------------------------------------------
# LLM-synthesised report
# ---------------------------------------------------------------------------

_LLM_REPORT_SYSTEM = """\
You are a senior brand strategist at a Fortune 500 analytics consultancy.
You will receive a JSON object containing brand-visibility metrics for a
company's presence across major LLM platforms (ChatGPT, Claude, Perplexity).

Write a polished strategy memorandum with the following sections:

1. **Executive Summary** — 3-4 sentences summarising the brand's AI visibility posture.
2. **Competitive Positioning** — analyse competitor displacement and share-of-voice.
3. **Risk Analysis** — flag any negative sentiment or criticism patterns.
4. **Recommended Actions** — 4-6 specific, actionable recommendations with priority levels.

Tone: professional, data-driven, concise.  Reference specific numbers from the metrics.
Format: use markdown headers and bullet points.
Length: 600-900 words.
"""


def generate_llm_report(brand: str = "HubSpot") -> str:
    """Generate a narrative report using an LLM to synthesise insights."""
    settings = get_settings()
    metrics = collect_metrics(brand)

    client = openai.OpenAI(api_key=settings.llm.openai_api_key)
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": _LLM_REPORT_SYSTEM},
            {"role": "user", "content": json.dumps(metrics, default=str)},
        ],
        temperature=0.4,
        max_tokens=2048,
    )

    report_text = response.choices[0].message.content or ""
    logger.info("LLM report generated (%d chars)", len(report_text))
    return report_text


# ---------------------------------------------------------------------------
# Persistence
# ---------------------------------------------------------------------------

def save_report(report_text: str, metrics: Dict | None = None, report_type: str = "full") -> str:
    """Persist the report to the ``strategy_reports`` table and return the report_id."""
    import uuid

    report_id = str(uuid.uuid4())
    execute(
        """
        INSERT INTO strategy_reports (report_id, report_type, report_content, metrics_snapshot)
        VALUES (%s, %s, %s, %s)
        """,
        (report_id, report_type, report_text, json.dumps(metrics or {}, default=str)),
    )
    logger.info("Report %s saved (type=%s)", report_id, report_type)
    return report_id


# ---------------------------------------------------------------------------
# Main entry point
# ---------------------------------------------------------------------------

def generate_report(
    brand: str = "HubSpot",
    mode: str = "template",
    persist: bool = True,
) -> str:
    """
    Generate a strategy report.

    Args:
        brand: Target brand.
        mode: "template" for deterministic, "llm" for AI-synthesised.
        persist: Whether to save the report to the database.

    Returns:
        The report text.
    """
    if mode == "llm":
        report = generate_llm_report(brand)
    else:
        report = generate_template_report(brand)

    if persist:
        metrics = collect_metrics(brand)
        save_report(report, metrics, report_type=mode)

    return report
